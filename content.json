{"meta":{"title":"陌上烟雨寒的空间","subtitle":"","description":"","author":"zhangpp","url":"https://2763899039zpp.github.io","root":"/"},"pages":[{"title":"about","date":"2023-03-10T03:16:59.000Z","updated":"2023-03-10T03:18:05.489Z","comments":true,"path":"about/index.html","permalink":"https://2763899039zpp.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-03-10T03:16:24.000Z","updated":"2023-03-10T03:18:30.531Z","comments":true,"path":"categories/index.html","permalink":"https://2763899039zpp.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-03-10T03:15:34.000Z","updated":"2023-03-22T06:34:59.141Z","comments":true,"path":"tags/index.html","permalink":"https://2763899039zpp.github.io/tags/index.html","excerpt":"","text":""},{"title":"contact","date":"2023-03-10T03:17:52.000Z","updated":"2023-03-10T03:18:16.155Z","comments":true,"path":"contact/index.html","permalink":"https://2763899039zpp.github.io/contact/index.html","excerpt":"","text":""}],"posts":[{"title":"async的用法和异常捕获","slug":"await中的异常捕获","date":"2023-03-21T07:45:22.000Z","updated":"2023-03-22T05:26:30.842Z","comments":true,"path":"2023/03/21/await中的异常捕获/","link":"","permalink":"https://2763899039zpp.github.io/2023/03/21/await%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/","excerpt":"","text":"基本用法async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice; &#125; // 以下是两种调用getStockPriceByName的方法 // 方法一 getStockPriceByName('goog').then(function (result) &#123; console.log(result); &#125;); // 方法二 async function test()=>&#123; const result = await getStockPriceByName('goog'); console.log(result); &#125; 下面是另一个例子，指定多少毫秒后输出一个值。 function timeout(ms) &#123; return new Promise((resolve) => &#123; setTimeout(resolve, ms); &#125;); &#125; // async function timeout(ms) &#123; // await new Promise((resolve) => &#123; // setTimeout(resolve, ms); // &#125;); //&#125; async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value); &#125; asyncPrint(\"hello world\", 50); 上面代码指定 50 毫秒以后，输出 hello world。 async 函数有多种使用形式。 // 函数声明 async function foo() &#123;&#125; // 函数表达式 const foo = async function () &#123;&#125;; // 箭头函数 const foo = async () => &#123;&#125;; 语法async 函数返回一个 Promise 对象 async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。 async function test() &#123; return \"hello world\"; &#125; test().then((v) => console.log(v)); // \"hello world\" async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象会被 catch 方法回调函数接收到 async function f() &#123; throw new Error(\"出错了\"); &#125; f().then( (v) => console.log(\"resolve\", v), (e) => console.log(\"reject1\", e) ); //reject Error: 出错了 错误处理可以像上面的方法中处理错误防止出错的方法，也是将其放在 try…catch 代码块之中。 async function f() &#123; try &#123; await new Promise(function (resolve, reject) &#123; throw new Error(\"出错了\"); &#125;); &#125; catch (e) &#123;&#125; return await \"hello world\"; &#125; 使用注意点第一点，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中 第二点，多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。 // 写法一 let [foo, bar] = await Promise.all([getFoo(), getBar()]); // 写法二 let fooPromise = getFoo(); let barPromise = getBar(); let foo = await fooPromise; let bar = await barPromise; 第三点，await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。如果在循环中使用 await 不能使用 forEach 循环，而应该使用 for 循环； function dbFuc(db) &#123; //这里不需要 async let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; // 可能得到错误结果 docs.forEach(async function (doc) &#123; await db.post(doc); &#125;); &#125; 上面代码可能不会正常工作，原因是这时三个 db.post()操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用 for 循环。 async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; for (let doc of docs) &#123; await db.post(doc); &#125; &#125;","categories":[],"tags":[]},{"title":"你不知道的javascript","slug":"book/你不知道的javascript","date":"2023-03-09T08:42:40.000Z","updated":"2023-03-14T03:10:35.010Z","comments":true,"path":"2023/03/09/book/你不知道的javascript/","link":"","permalink":"https://2763899039zpp.github.io/2023/03/09/book/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript/","excerpt":"","text":"第一章 作用域是什么编译原理 分词&#x2F;词法分析 （Tokenizing&#x2F;Lexing）将代码字符串分解成有意义的代码块，这些代码块称为词法单元（token） 解析&#x2F;语法分析 （Parsing）这个过程是将词法单元流转化成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST） 代码生成将 AST 转换为可执行代码的过程称被称为代码生成 理解作用域 引擎负责整个javascript程序的编译及执行 编译器负责语法缝隙及代码生成 作用域确定当前执行的代码对这些标识符的访问权限 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。 RHS: 谁是赋值操作的源头 retrieve his source value（取到它的源值）LHS: 赋值操作的目标是谁 作用域嵌套引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止 异常 ReferenceError执行LHS查询时 在作用域寻找不到变量 引擎就会抛出该错误 TypeError对一个非函数类型的值进行函数调用引用null或undefined类型的值中的属性 var a &#x3D; 2; a(); &#x2F;&#x2F; TypeError var b b.length; &#x2F;&#x2F; TypeError 小测验 function foo(a)&#123; var b &#x3D; a; return a + b; &#125; var c &#x3D; foo(2) 找出所有的 LHS 查询（这里有 3 处！）c &#x3D; ..; 、 a &#x3D; 2 （隐式变量分配）、 b &#x3D; .. 找出所有的 RHS 查询（这里有 4 处！）foo(2.. 、 &#x3D; a; 、 a .. 、 .. b","categories":[{"name":"book","slug":"book","permalink":"https://2763899039zpp.github.io/categories/book/"}],"tags":[{"name":"js","slug":"js","permalink":"https://2763899039zpp.github.io/tags/js/"},{"name":"book","slug":"book","permalink":"https://2763899039zpp.github.io/tags/book/"}]},{"title":"node 学习（自用）","slug":"node/node学习（自用）","date":"2023-03-09T08:42:40.000Z","updated":"2023-03-22T05:27:33.883Z","comments":true,"path":"2023/03/09/node/node学习（自用）/","link":"","permalink":"https://2763899039zpp.github.io/2023/03/09/node/node%E5%AD%A6%E4%B9%A0%EF%BC%88%E8%87%AA%E7%94%A8%EF%BC%89/","excerpt":"","text":"2 fs 文件系统模块const fs = require(\"fs\"); 2.1 读取文件中的指定内容fs.readFile() 语法格式 fs.readFile(path[,options],callback) path：路径options：编码格式callback：读完文件后拿到的结果 const fs = require(\"fs\"); fs.readFile(\"./files/11.txt\", \"utf8\", function (err, dataStr) &#123; if (err) &#123; return console.log(\"读取文件失败！\" + err.message); &#125; console.log(\"文件读取成功，内容是：\" + dataStr); &#125;); 2.2 fs 向指定文件中写入内容fs.writeFile(file,data[,options]) ,callback file：文件内容data：写入的内容options：写入内容的格式callback：写完文件后拿到的结果 fs.writeFile(&#39;.&#x2F;files&#x2F;22.txt&#39;, &#39;Hello Node.js&#39;, function (err) &#123; if (err) &#123; return console.log(&#39;文件写入失败！&#39; + err.message) &#125; console.log(&#39;文件写入成功！&#39;) &#125;) 2.3 fs 模块路径动态拼接的问题在使用 fs 模块操作文件时，如果提供的操作路径是以./或../开头的相对路径时，很容易出现路径动态拼写错误的问题原因：代码在运行的 1 时候，会执行 node 命令所处的目录，动态拼接出被操作文件的完整路径。 解决方法：直接提供一个完整的文件存放路径 __dirname表示当前目录所处的目录 3 path 路径模块3.1 什么是 path 路径模块path 模块是 Node.js 官方提供的、用来处理路径的模块。他提供了一系列的方法和属性，用来满足用户对路径的处理需求。path.join()方法，用来将多个路径拼接成一个完整的路径字符串path.basename()方法，用来从字符串中，解析出文件名 导入 const path &#x3D; require(&#39;path&#39;) 3.2 路径拼接const pathStr &#x3D; path.join(&#39;&#x2F;a&#39;,&#39;&#x2F;b&#x2F;c&#39;,&#39;..&#x2F;..&#x2F;&#39;,&#39;.&#x2F;d&#39;,&#39;e&#39;) 注意 ..&#x2F;会抵消前面的路径 路径拼接的时候尽量使用 path.join()方法而不是字符串的拼接方法。 3.3 获取文件中的文件名path.basename(path[,ext]) path 必选参数，表示路径的字符串ext 可选参数，表示文件的扩展名返回 表示路径中的最后一部分 3.4 获取路径文件中的文件扩展名path.extname(path) path 必选参数，表示路径字符串返回 返回得到扩展名字符串 3.5 综合案例注意fs.writeFile()方法只能用来创建路径重复调用 fs.writeFile()写入同一个文件，新写入的内容会覆盖之前旧的内容。 4 http 模块4.1 什么是 http 模块在网络节点中，负责消费资源的电脑，叫做客户端；**负责对外提供网络资源的电脑**，叫做服务器。 http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。通过 http 模块提供的 http.createServer() 方法，就能方便的把一台普通的电脑，变成一台 Web 服务器，从而对外提供 Web 资源服务。 const http &#x3D; require(&#39;http&#39;) 4.2 进一步理解 http 模块的作用服务器和普通电脑的区别在于，服务器上安装了 web 服务器软件，例如：IIS、Apache 等。通过安装这些服务器软件，就能把一台普通的电脑变成一台 web 服务器。 在 Node.js 中，我们不需要使用 IIS、Apache 等这些第三方 web 服务器软件。因为我们可以基于 Node.js 提供的http 模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供 web 服务。 4.3 服务器相关的概念 IP 地址IP 地址就是互联网上每台计算机的唯一地址，因此 IP 地址具有唯一性。如果把“个人电脑”比作“一台电话”，那么“IP 地址”就相当于“电话号码”，只有在知道对方 IP 地址的前提下，才能与对应的电脑之间进行数据通信。IP 地址的格式：通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0~255 之间的十进制整数。例如：用点分十进表示的 IP 地址（192.168.1.1）注意：① 互联网中每台 Web 服务器，都有自己的 IP 地址，例如：大家可以在 Windows 的终端中运行 ping www.baidu.com 命令，即可查看到百度服务器的 IP 地址。② 在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入 127.0.0.1 这个IP 地址，就能把自己的电脑当做一台服务器进行访问了。 域名和域名服务器尽管 IP 地址能够唯一地标记网络上的计算机，但 IP 地址是一长串数字，不直观，而且不便于记忆，于是人们又发明了另一套字符型的地址方案，即所谓的域名（Domain Name）地址。IP 地址和域名是一一对应的关系，这份对应关系存放在一种叫做域名服务器(DNS，Domain name server)的电脑中。使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，域名服务器就是提供 IP 地址和域名之间的转换服务的服务器。注意：① 单纯使用 IP 地址，互联网中的电脑也能够正常工作。但是有了域名的加持，能让互联网的世界变得更加方便。② 在开发测试期间， 127.0.0.1 对应的域名是 localhost，它们都代表我们自己的这台电脑，在使用效果上没有任何区别。 端口号计算机中的端口号，就好像是现实生活中的门牌号一样。通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你的手中。同样的道理，在一台电脑中，可以运行成百上千个 web 服务。每个 web 服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的 web 服务进行处理。注意：① 每个端口号不能同时被多个 web 服务占用。② 在实际应用中，URL 中的80 端口可以被省略。 4.4 创建最基本的 web 服务器const http = require(\"http\"); const server = http.createServer(); server.on(\"request\", (req, res) => &#123; const url = req.url; const method = req.method; const str = `your request url is $&#123;url&#125;,and request method is $&#123;method&#125;`; console.log(str); console.log(\"Someone visit our web server\"); res.end(str); &#125;); server.listen(8081, () => &#123; console.log(\"serve running at http://127.0.0.1:8081\"); &#125;); 解决中文乱码问题 res.setHeader(&#39;Content-Type&#39;, &#39;text&#x2F;html; charset&#x3D;utf-8&#39;) 4.6 案例-实现读取文件的内容并响应到客户端 const http = require(\"http\"); const fs = require(\"fs\"); const path = require(\"path\"); const server = http.createServer(); server.on(\"request\", (req, res) => &#123; // 获取到客户端请求的url let url = req.url; // 把请求的url地址映射到具体的地址 const fPath = path.join(__dirname, url); // 根据映射的文件路径读取文件内容 fs.readFile(fPath, \"utf8\", (err, dataStr) => &#123; // 文件读取失败，响应错误信息 if (err) return res.end(\"404 not found\"); // 文件读取成功，将读取成功的内容响应到客户端 res.end(dataStr); &#125;); &#125;); server.listen(8081, () => &#123; console.log(\"http://127.0.0.1:8081\"); &#125;); 模块化1. 模块化的基本概念模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元。 编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块。把代码进行模块化拆分的好处：① 提高了代码的复用性② 提高了代码的可维护性③ 可以实现按需加载\\ 1.2 模块化规范模块化规范就是对代码进行模块化的拆分与组合时，需要遵守的那些规则。 模块化规范的好处：大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己 2. Node.js 中的模块化2.1 Node.js 中模块的分类Node.js 中根据模块来源的不同，将模块分为了 3 大类，分别是： 内置模块（内置模块是由 Node.js 官方提供的，例如 fs、path、http 等） 自定义模块（用户创建的每个 .js 文件，都是自定义模块） 第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载） 2.2 加载模块使用require()方法，可以加在以上三种模块注意：使用 require() 方法加载其它模块时，会执行被加载模块中的代码。 2.3 Node.js 中的模块作用域和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域 2.4 向外共享模块作用域中的成员 module 对象在每一个.js 自定义模块中都有一个 module 对象，它存储了当前模块有关的信息，打印如下。 module.exports 对象在自定义模块中可以使用 module.exports 对象，将模块内部成员共享出去，工外界使用。外界用 require()方法导入自定义模块时，得到的就是 module.exports 所指向的对象。 共享成员时的注意点使用 require()方法导入模块时，导入的结果永远以module.exports指向的对象为主 exports.username &#x3D; &#39;zs&#39;, module.exports &#x3D; &#123; gender: &#39;男&#39;, age: 22 &#125; &#x2F;&#x2F; &#123;gender: &#39;男&#39;,age: 22&#125; module.exports.username &#x3D; &#39;zs&#39;, exports &#x3D; &#123; gender: &#39;男&#39;, age: 22 &#125; &#x2F;&#x2F; &#123;username : &#39;zs&#39;&#125; exports.username &#x3D; &#39;zs&#39;, module.exports. gender &#x3D; &#39;&#39;男 &#x2F;&#x2F; &#123;username : &#39;zs&#39; , gender: &#39;男&#39;&#125; exports &#x3D; &#123; gender: &#39;男&#39;, age: 22 &#125; module.exports&#x3D; exports &#x2F;&#x2F; &#123;username : &#39;zs&#39; , gender: &#39;男‘’, age: 22&#125; exports 对象exportd 和 module.exports 指向同一个对象由于 module.exports 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了 exports 对象。默认情况下，exports 和 module.exports 指向同一个对象。最终共享的结果，还是以 module.exports 指向的对象为准 2.5 Node.js 中的模块化规范 Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何相互依赖。CommonJS 规定：① 每个模块内部，module 变量代表当前模块。② module 变量是一个对象，它的 exports 属性（即 module.exports）对外的接口。③ 加载某个模块，其实是加载该模块的 module.exports 属性。require() 方法用于加载模块。 3. npm 与包3.1 包 什么是包Node.js 中的第三方模块又叫做包。就像电脑和计算机指的是相同的东西，第三方模块和包指的是同一个概念，只不过叫法不同。 包的来源不同于 Node.js 中的内置模块与自定义模块，包是由第三方个人或团队开发出来的，免费供所有人使用。注意：Node.js 中的包都是免费且开源的，不需要付费即可免费下载使用 为什么需要包由于 Node.js 的内置模块仅提供了一些底层的 API，导致在基于内置模块进行项目开发的时，效率很低。包是基于内置模块封装出来的，提供了更高级、更方便的 API，极大的提高了开发效率。 包和内置模块之间的关系，类似于 jQuery 和 浏览器内置 API 之间的关系 从 https://www.npmjs.com/ 网站上搜索自己所需要的包 从 https://registry.npmjs.org/ 服务器上下载自己需要的包 3.3 包管理配置文件 快速创建 package.jsonnpm 包管理工具提供了一个快捷命令，可以在执行命令时所处的目录中，快速创建 package.json 这个包管理 npm init -y ① 上述命令只能在英文的目录下成功运行！所以，项目文件夹的名称一定要使用英文命名，不要使用中文，不能出现空格。② 运行 npm install 命令安装包的时候，npm 包管理工具会自动把包的名称和版本号，记录到 package.json 中。 dependenciesdependencies 专门用来记录您使用 npm install 命令安装了哪些包。 devDependencies 节点如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到 devDependencies 节点中。与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 ddependencies 节点中 &#x2F;&#x2F; 将包记录到devDdependencies节点中 &#x2F;&#x2F; 简写 npm i 包名 -D &#x2F;&#x2F; 完整写法 npm install 包名 --save-dev 3.4 解决下包速度慢的问题 利用镜像 &#x2F;&#x2F; 查看当前的下包镜像 npm config get registry &#x2F;&#x2F; 将下包的镜像源切换为淘宝镜像源 npm config set registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F; nrm为了更方便的切换下包的镜像源，我们可以安装 nrm 这个小工具，利用 nrm 提供的终端命令，可以快速查看和切换下包的镜像源。 &#x2F;&#x2F; 安装nrm nrm i nrm -g &#x2F;&#x2F; 查看所有可用的镜像 nrm ls &#x2F;&#x2F;将下包的镜像源切换成tabboo镜像 nrm use taobao 3.8 发布包 注册 npm 账号① 访问 https://www.npmjs.com/ 网站，点击 sign up 按钮，进入注册用户界面② 填写账号相关的信息：Full Name、Public Email、Username、Password③ 点击 Create an Account 按钮，注册账号④ 登录邮箱，点击验证链接，进行账号的验证 登录 npm 账号npm 账号注册完成后，可以在终端中执行 npm login 命令，依次输入用户名、密码、邮箱后，即可登录成功。注意：在运行 npm login 命令之前，必须先把下包的服务器地址切换为 npm 的官方服务器。否则会导致发布包失败 把包发布到 npm 上将终端切换到包的根目录之后，运行 npm publish 命令，即可将包发布到 npm 上（注意：包名不能雷同）。 删除已发布的包运行 npm unpublish 包名 –force 命令，即可从 npm 删除已发布的包 4. 模块的加载机制4.1 优先从缓存中加载模块在第一次加载后会被缓存。 这也意味着多次调用 require() 不会导致模块的代码被执行多次。注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率 4.2 内置模块的加载机制内置模块是由 Node.js 官方提供的模块，内置模块的加载优先级最高。 4.3 自定义模块的加载机制使用 require() 加载自定义模块时，必须指定以 .&#x2F; 或 ..&#x2F; 开头的路径标识符。在加载自定义模块时，如果没有指定 .&#x2F; 或 ..&#x2F; 这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。同时，在使用 require() 导入自定义模块时，如果省略了文件的扩展名，则 Node.js 会按顺序分别尝试加载以下的文件：① 按照确切的文件名进行加载② 补全 .js 扩展名进行加载③ 补全 .json 扩展名进行加载④ 补全 .node 扩展名进行加载⑤ 加载失败，终端报错 4.4 第三方模块的加载机制如果传递给 require() 的模块标识符不是一个内置模块，也没有以 ‘.&#x2F;’ 或 ‘..&#x2F;’ 开头，则 Node.js 会从当前模块的父目录开始，尝试从 &#x2F;node_modules 文件夹中加载第三方模块。如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。 4.5 目录作为模块当把目录作为模块标识符，传递给 require() 进行加载的时候，有三种加载方式：① 在被加载的目录下查找一个叫做 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口② 如果目录里没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。③ 如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：Error: Cannot find module ‘xxx’ Express1. 初识 Express1.1 Express 简介 什么是 Express官方给出的概念：Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。通俗的理解：Express 的作用和 Node.js 内置的 http 模块类似，是专门用来创建 Web 服务器的。Express 的本质：就是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法 1.2 Express 的基本使用 安装 npm i express@4.17.1 const express = require(\"express\"); const app = express(); // 通过 app.get() 方法，可以监听客户端的 GET 请求 app.get(\"/user\", (req, res) => &#123; res.send(&#123; name: \"zs\", age: 20, sex: \"男\" &#125;); &#125;); // 通过 app.post() 方法，可以监听客户端的 POST 请求 app.post(\"/user\", (req, res) => &#123; res.send(&#123; name: \"ls\", age: 20, sex: \"男\" &#125;); &#125;); // 通过 res.send() 方法，可以把处理好的内容，发送给客户端 app.get(\"/\", (req, res) => &#123; // 通过 req.query 对象，可以访问到客户端通过查询字符串的形式，发送到服务器的参数 // ?name=zs&amp;age=20 console.log(req.query); res.send(req.query); &#125;); // 通过 req.params 对象，可以访问到 URL 中，通过 : 匹配到的动态参数： app.get(\"/user/:id\", (req, res) => &#123; console.log(req.params); res.send(req.params); &#125;); // 调用express.static() 方法，快速的对外提供静态资源 app.use(\"/abc\", express.static(\"./clock\")); app.use(express.static(\"./files\")); // 可以通过 http://127.0.0.1:8081/abc/index.html 访问clock中的文件 app.listen(8081, () => &#123; console.log(\"serve running at http://127.0.0.1:8081\"); &#125;); nodemon 为什么要使用 nodemon在编写调试 Node.js 项目的时候，如果修改了项目的代码，则需要频繁的手动 close 掉，然后再重新启动，非常繁琐。现在，我们可以使用 nodemon（https://www.npmjs.com/package/nodemon） 这个工具，它能够监听项目文件的变动，当代码被修改后，nodemon 会自动帮我们重启项目，极大方便了开发和调试 安装 nodemon npm install -g nodemon 使用 nodemon 运行 node app.js 命令 —&gt; nodemon app.js 来启动项目。 node app.js &#x2F;&#x2F; 改为 nodemon app.js 2. Express 路由2.1 路由的概念 什么是路由广义上来讲，路由就是映射关系 Express 中的路由在 Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系 2.2 路由的使用 最简单的用法 const express = require(\"express\"); const app = express(); // 挂载路由 app.get(\"/\", (req, res) => &#123; res.send(\"hello word\"); &#125;); app.post(\"/\", (req, res) => &#123; res.send(\"post request\"); &#125;); app.listen(8081, () => &#123; console.log(\"serve running at http://127.0.0.1:8081\"); &#125;); 模块化路由① 创建路由模块对应的 .js 文件② 调用 express.Router() 函数创建路由对象③ 向路由对象上挂载具体的路由④ 使用 module.exports 向外共享路由对象⑤ 使用 app.use() 函数注册路由模块 03_router.js const express = require(\"express\"); const router = express.Router(); router.get(\"/user/list\", (req, res) => &#123; res.send(\"get user list\"); &#125;); router.post(\"/user/add\", (req, res) => &#123; res.send(\"Add new user\"); &#125;); module.exports = &#123; router, &#125;; 模块化路由.js const express = require(\"express\"); const app = express(); const &#123; router &#125; = require(\"./03_router\"); // app.use是用来注册全局中间件的 统一加上前缀 app.use(\"/api\", router); app.listen(8081, () => &#123; console.log(\"serve running at http://127.0.0.1:8081\"); &#125;); 3. Express 中间件3.1 中间件的概念 什么是中间件中间件（Middleware ），特指业务流程的中间处理环节 中间件的格式 app.get(&#39;&#x2F;&#39;,function(req,res,next)&#123; next(); &#125;) next 函数的作用next 函数是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由。 3.2 中间件初体验 4. 定义中间件函数 const mw &#x3D; function (req, res, next) &#123; console.log(&#39;中间件&#39;) next(); &#125; app.use(mw) 定义全局中间件的简化形式 &#x2F;&#x2F; 简化版的中间件 app.use(function (req, res, next) &#123; console.log(&#39;这是一个最简单的中间件函数&#39;) next() &#125;) 中间件的作用多个中间件之间，共享同一份 req 和 res。基于这样的特性，我们可以在上游的中间件中，统一为 req 或 res 对象添加自定义的属性或方法，供下游的中间件或路由进行使用。 定义多个全局中间件可以使用 app.use() 连续定义多个全局中间件。客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行调用。 局部生效的中间件 app.get(&#39;&#x2F;&#39;, mw1, (req, res) &#x3D;&gt; &#123; res.send(&#39;hello word&#39; + req.startTime); &#125;) app.get(&#39;&#x2F;&#39;, mw1, mw2, (req, res) &#x3D;&gt; &#123; res.send(&#39;hello word&#39; + req.startTime); &#125;) 了解中间件的 5 个使用注意事项① 一定要在路由之前注册中间件② 客户端发送过来的请求，可以连续调用多个中间件进行处理③ 执行完中间件的业务代码之后，不要忘记调用 next() 函数④ 为了防止代码逻辑混乱，调用 next() 函数后不要再写额外的代码⑤ 连续调用多个中间件时，多个中间件之间，共享 req 和 res 对象 3.3 中间件的分类 应用级别的中间件 路由级别的中间件 错误级别的中间件 express 内置中间件 第三方中间件 应用级别的中间件通过 app.use() 或 app.get() 或 app.post() ，绑定到 app 实例上的中间件，叫做应用级别的中间件 路由级别的中间件绑定到 express.Router() 实例上的中间件，叫做路由级别的中间件。它的用法和应用级别中间件没有任何区别。 router.use(function(req,res,next)&#123; console.log(&#39;time:&#39;,Date.new()) next(); &#125;) 错误级别的中间件 app.use((err, req, res, next) &#x3D;&gt; &#123; console.log(&#39;捕获错误&#39;) res.send(err.message) next() &#125;) Express 内置的中间件① express.static 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性）② express.json 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）③ express.urlencoded 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用） app.use(express.json()).use(express.urlencoded(&#123; extended: false &#125;)); 第三方的中间件例如使用 body-parser npm i body-parser const parser = require(\"body-parser\"); app.use(parser.urlencoded(&#123; extended: false &#125;)); 自定义解析表单的中间件 const express = require(\"express\"); const qs = require(\"querystring\"); const app = express(); app.use((req, res, next) => &#123; // 自定义中间件的具体逻辑 let str = \"\"; req.on(\"data\", (chunk) => &#123; str += chunk; &#125;); req.on(\"end\", () => &#123; let data = qs.parse(str); req.body = data; next(); &#125;); &#125;); app.post(\"/user\", (req, res) => &#123; res.send(req.body); &#125;); app.listen(8081, function () &#123; console.log(\"http://127.0.0.1:8081\"); &#125;); 自定义中间件的模块化 12_custom-body-parser.js const qs = require(\"querystring\"); const bodyParser = (req, res, next) => &#123; let str = \"\"; req.on(\"data\", (chunk) => &#123; str += chunk; &#125;); req.on(\"end\", () => &#123; req.body = qs.parse(str); // 调用qs.prase方法，把查询到的字符串解析为对象 next(); &#125;); &#125;; module.exports = bodyParser; const express = require(\"express\"); const qs = require(\"querystring\"); const cors = require(\"cors\"); // 引入中间件 const customBodyParser = require(\"./12_custom-body-parser\"); const app = express(); app.use(cors()); // 使用自定义的中间件 app.use(customBodyParser); app.post(\"/user\", (req, res) => &#123; res.send(req.body); &#125;); app.listen(8081, function () &#123; console.log(\"http://127.0.0.1:8081\"); &#125;); 4. 使用 Express 写接口4.5 CORS 跨域资源共享 接口的跨域问题解决接口跨域问题的方案主要有两种：① CORS（主流的解决方案，推荐使用）② JSONP（有缺陷的解决方案：只支持 GET 请求） 使用 cors 中间件解决跨域问题① 运行 npm install cors 安装中间件② 使用 const cors &#x3D; require(‘cors’) 导入中间件③ 在路由之前调用 app.use(cors()) 配置中间件 CORS 响应头部 - Access-Control-Allow-Origin res.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;http:&#x2F;&#x2F;itcast.cn&#39;) 通配符 *，表示允许来自任何域的请求， res.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;) CORS 响应头部 - Access-Control-Allow-Headers默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text&#x2F;plain、multipart&#x2F;form-data、application&#x2F;x-www-form-urlencoded 三者之一）如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败！ res.setHeader(&#39;Access-Control-Allow-Headers&#39;,&#39;Content-Type,X-Custom-Header&#39;) CORS 响应头部 - Access-Control-Allow-Methods默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods来指明实际请求所允许使用的 HTTP 方法。 &#x2F;&#x2F; 只允许post get post head 请求 res.setHeader(&#39;Access-Control-Allow-Methods&#39;,&#39;POST&#39;,&#39;GET&#39;,&#39;DELETE&#39;,&#39;HEAD&#39;); &#x2F;&#x2F; 允许所有的http请求方法 res.setHeader(&#39;Access-Control-Allow-Methods&#39;,&#39;*&#39;); CORS 请求的分类客户端在请求 CORS 接口时，根据请求方式和请求头的不同，可以将 CORS 的请求分为两大类，分别是：① 简单请求② 预检请求 简单请求同时满足以下两大条件的请求，就属于简单请求：① 请求方式：GET、POST、HEAD 三者之一② HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值 application&#x2F;x-www-form\u0002urlencoded、multipart&#x2F;form-data、text&#x2F;plain） 预检请求只要符合以下任何一个条件的请求，都需要进行预检请求：① 请求方式为 GET、POST、HEAD 之外的请求 Method 类型② 请求头中包含自定义头部字段③ 向服务器发送了 application&#x2F;json 格式的数据在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据。 简单请求和预检请求的区别简单请求的特点：客户端与服务器之间只会发生一次请求。预检请求的特点：客户端与服务器之间会发生两次请求，OPTION 预检请求成功之后，才会发起真正的请求。 数据库操作4. 在项目中操作 MySQL4.1 在项目中操作数据库的步骤① 安装操作 MySQL 数据库的第三方模块（mysql）② 通过 mysql 模块连接到 MySQL 数据库③ 通过 mysql 模块执行 SQL 语句4.2 安装与配置 mysql 模块 安装 npm install mysql 配置 mysql 模块 const mysql &#x3D; require(&#39;mysql&#39;); const db &#x3D; mysql.createPool(&#123; host: &#39;127.0.0.1&#39;, user: &#39;root&#39;, password: &#39;1234&#39;, database: &quot;student&quot; &#125;) 4.3 使用 mysql 模块操作 MySQL 数据库 &#x2F;&#x2F; 查询user表中的数据 db.query(&#39;SELECT * from user&#39;, (err, result) &#x3D;&gt; &#123; if (err) return console.log(err.message); console.log(result) &#125;) &#x2F;&#x2F; 向user表中插入一条数据 const user &#x3D; &#123; name: &#39;zhangpp&#39;, score: 20, sex: &#39;女&#39; &#125;; const sqlStr &#x3D; &#39;insert into user (name,score,sex) values (?,?,?)&#39;; db.query(sqlStr, [user.name, user.score, user.sex], (err, result) &#x3D;&gt; &#123; if (err) return console.log(err.message); if (result.affectedRows &#x3D;&#x3D; 1) &#123; console.log(&#39;插入成功&#39;) &#125; console.log(result) &#125;) &#x2F;&#x2F; 插入一行的简单写法 const user &#x3D; &#123; name: &#39;zhangpp&#39;, score: 20, sex: &#39;女&#39; &#125;; const sqlStr &#x3D; &#39;insert into user set ?&#39; db.query(sqlStr, user, (err, result) &#x3D;&gt; &#123; if (err) return console.log(err.message); if (result.affectedRows &#x3D;&#x3D; 1) &#123; console.log(&#39;插入成功&#39;) &#125; console.log(result) &#125;) &#x2F;&#x2F; 更新数据 const user &#x3D; &#123; id: 3, name: &#39;lll&#39;, score: 15, sex: &#39;女&#39; &#125;; const sqlStr &#x3D; &#39;update user set name&#x3D;?,score&#x3D;? where id&#x3D;?&#39; db.query(sqlStr, [user.name, user.score, user.id], (err, result) &#x3D;&gt; &#123; if (err) return console.log(err.message); if (result.affectedRows &#x3D;&#x3D; 1) &#123; console.log(&#39;修改成功&#39;) &#125; console.log(result) &#125;) &#x2F;&#x2F; 更新数据的便捷方法 const user &#x3D; &#123; id: 3, name: &#39;lle&#39;, score: 15, sex: &#39;女&#39; &#125;; const sqlStr &#x3D; &#39;update user set ? where id&#x3D;?&#39; db.query(sqlStr, [user, user.id], (err, result) &#x3D;&gt; &#123; if (err) return console.log(err.message); if (result.affectedRows &#x3D;&#x3D; 1) &#123; console.log(&#39;修改成功&#39;) &#125; console.log(result) &#125;) &#x2F;&#x2F; 删除数据 const sqlStr &#x3D; &quot;delete from user where id&#x3D;?&quot; db.query(sqlStr, 3, (err, result) &#x3D;&gt; &#123; if (err) return console.log(err.message); if (result.affectedRows &#x3D;&#x3D; 1) &#123; console.log(&#39;删除成功&#39;) &#125; console.log(result) &#125;) 前后端的身份认证5.1 Web 开发模式目前主流的 Web 开发模式有两种，分别是：① 基于服务端渲染的传统 Web 开发模式② 基于前后端分离的新型 Web 开发模式 服务端渲染的优缺点优点：① 前端耗时少。因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电。② 有利于 SEO。因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于 SEO。缺点：① 占用服务器端资源。即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。② 不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于项目高效开发 前后端分离的优缺点优点：① 开发体验好。前端专注于 UI 页面的开发，后端专注于 api 的开发，且前端有更多的选择性。② 用户体验好。Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新。③ 减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的。缺点：① 不利于 SEO。因为完整的 HTML 页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。（解决方案：利用 Vue、React 等前端框架的 SSR （server side render）技术能够很好的解决 SEO 问题！） 5.2 身份认证 3. 不同开发模式下的身份认证对于服务端渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案：① 服务端渲染推荐使用 Session 认证机制② 前后端分离推荐使用 JWT 认证机制 5.4 在 Express 中使用 Session 认证 4. 安装 express-session 中间件 npm i express-session &#x2F;&#x2F; 配置 Session 中间件 const session &#x3D; require(&#39;express-session&#39;); app.use(session(&#123; secret: &#39;zpp&#39;, resave: false, saveUninitialized: true &#125;)) 可通过 req.session 来访问和使用 session 对象 app.post(&#39;&#x2F;api&#x2F;login&#39;, (req, res) &#x3D;&gt; &#123; &#x2F;&#x2F; 判断用户提交的登录信息是否正确 if (req.body.username !&#x3D;&#x3D; &#39;admin&#39; || req.body.password !&#x3D;&#x3D; &#39;000000&#39;) &#123; return res.send(&#123; status: 1, msg: &#39;登录失败&#39; &#125;) &#125; &#x2F;&#x2F; 登录成功后的用户信息，保存到 Session 中 req.session.username &#x3D; req.body.username; req.session.isLogin &#x3D; true; res.send(&#123; status: 0, msg: &#39;登录成功&#39; &#125;) &#125;) 可以直接从 req.session 对象上获取之前存储的数据 &#x2F;&#x2F; 获取用户姓名的接口 app.get(&#39;&#x2F;api&#x2F;username&#39;, (req, res) &#x3D;&gt; &#123; &#x2F;&#x2F; 从 Session 中获取用户的名称，响应给客户端 if (req.session.isLogin) &#123; res.send(&#123; status: 0, msg: &#39;success&#39;, username: req.session.username &#125;) &#125; else &#123; res.send(&#123; status: 1, msg: &#39;fail&#39; &#125;) &#125; &#125;) 调用 req.session.destroy() 函数，即可清空服务器保存的 session 信息 &#x2F;&#x2F; 退出登录的接口 app.post(&#39;&#x2F;api&#x2F;logout&#39;, (req, res) &#x3D;&gt; &#123; &#x2F;&#x2F; 清空 Session 信息 req.session.destroy() res.send(&#123; status: 0, msg: &#39;退出登录成功&#39; &#125;) &#125;) 5.5 JWT 认证机制 什么是 JWTJWT（英文全称：JSON Web Token）是目前最流行的跨域认证解决方案 JWT 的组成部分JWT 通常由三部分组成，分别是 Header（头部）、Payload（有效荷载）、Signature（签名）。三者之间使用英文的“.”分隔。 JWT 的三个部分各自代表的含义JWT 的三个组成部分，从前到后分别是 Header、Payload、Signature。 - Payload 部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串。 - Header 和 Signature 是安全性相关的部分，只是为了保证 Token 的安全性 JWT 的使用方式 - 客户端收到服务器返回的 JWT 之后，通常会将它储存在 localStorage 或 sessionStorage 中。 - 此后，客户端每次与服务器通信，都要带上这个 JWT 的字符串，从而进行身份认证。推荐的做法是把 JWT 放在 HTTP 请求头的 Authorization 字段中，格式如下： Authorization: Bearer &lt;token&gt; 5.6 在 Express 中使用 JWT 安装 JWT 相关的包 npm install jsontoken express-jwt jsonwebtoken 用于生成 JWT 字符串 express-jwt 用于将 JWT 字符串解析还原成 JSON 对象 导入 JWT 相关的包 const jwt &#x3D; require(&#39;jsonwebtoken&#39;); const expressJWT &#x3D; require(&#39;express-jwt&#39;); 定义 secret 密钥 const secretKey &#x3D; &#39;zhangpp&#39; 在登录成功后生成 JWT 字符串调用 jsonwebtoken 包提供的 sign() 方法，将用户的信息加密成 JWT 字符串，响应给客户端： const tokenStr &#x3D; jwt.sign(&#123; username: userinfo.username &#125;, secretKey, &#123; expiresIn: &#39;60s&#39; &#125;) 将 JWT 字符串还原为 JSON 对象服务器可以通过 express-jwt 这个中间件，自动将客户端发送过来的 Token 解析还原成 JSON 对象 app.use(expressJWT(&#123; secret: secretKey, algorithms: [&quot;HS256&quot;], credentialsRequired: false &#125;).unless(&#123; path: [&#39;&#x2F;api&#x2F;login&#39;] &#125;)) 使用 req.user 获取用户信息 app.get(&#39;&#x2F;admin&#x2F;getinfo&#39;, function (req, res) &#123; &#x2F;&#x2F; 使用 req.user 获取用户信息，并使用 data 属性将用户信息发送给客户端 console.log(&#39;admin&#39;) const user &#x3D; req.user console.log(&#39;username: &#39;, user); res.send(&#123; status: 200, message: &#39;获取用户信息成功！&#39;, data: req.user &#x2F;&#x2F; 要发送给客户端的用户信息 &#125;) &#125;) 捕获解析 JWT 失败后产生的错误 app.use((err, req, res, next) &#x3D;&gt; &#123; &#x2F;&#x2F; 这次错误是由token解析失败导致的 if (err.name &#x3D;&#x3D;&#x3D; &#39;UnauthorizedError&#39;) &#123; return res.send(&#123; status: 401, message: &#39;无效的token&#39;, &#125;) &#125; else &#123; res.send(&#123; status: 500, message: &#39;未知的错误&#39;, &#125;) &#125; &#125;) 全部代码 &#x2F;&#x2F; 导入 express 模块 const express &#x3D; require(&#39;express&#39;) &#x2F;&#x2F; 创建 express 的服务器实例 const app &#x3D; express() &#x2F;&#x2F; TODO_01：安装并导入 JWT 相关的两个包，分别是 jsonwebtoken 和 express-jwt const jwt &#x3D; require(&#39;jsonwebtoken&#39;); const expressJWT &#x3D; require(&#39;express-jwt&#39;); &#x2F;&#x2F; 允许跨域资源共享 const cors &#x3D; require(&#39;cors&#39;) app.use(cors()) &#x2F;&#x2F; 解析 post 表单数据的中间件 const bodyParser &#x3D; require(&#39;body-parser&#39;) app.use(bodyParser.urlencoded(&#123; extended: false &#125;)) &#x2F;&#x2F; TODO_02：定义 secret 密钥，建议将密钥命名为 secretKey const secretKey &#x3D; &#39;zhangpp&#39; &#x2F;&#x2F; TODO_04：注册将 JWT 字符串解析还原成 JSON 对象的中间件 app.use(expressJWT(&#123; secret: secretKey, algorithms: [&quot;HS256&quot;], credentialsRequired: false &#125;).unless(&#123; path: [&#39;&#x2F;api&#x2F;login&#39;] &#125;)) &#x2F;&#x2F; 登录接口 app.post(&#39;&#x2F;api&#x2F;login&#39;, function (req, res) &#123; &#x2F;&#x2F; 将 req.body 请求体中的数据，转存为 userinfo 常量 const userinfo &#x3D; req.body &#x2F;&#x2F; 登录失败 if (userinfo.username !&#x3D;&#x3D; &#39;admin&#39; || userinfo.password !&#x3D;&#x3D; &#39;000000&#39;) &#123; return res.send(&#123; status: 400, message: &#39;登录失败！&#39; &#125;) &#125; &#x2F;&#x2F; 登录成功 &#x2F;&#x2F; TODO_03：在登录成功之后，调用 jwt.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端 const tokenStr &#x3D; jwt.sign(&#123; username: userinfo.username &#125;, secretKey, &#123; expiresIn: &#39;60s&#39; &#125;) res.send(&#123; status: 200, message: &#39;登录成功！&#39;, token: tokenStr &#x2F;&#x2F; 要发送给客户端的 token 字符串 &#125;) &#125;) &#x2F;&#x2F; 这是一个有权限的 API 接口 app.get(&#39;&#x2F;admin&#x2F;getinfo&#39;, function (req, res) &#123; &#x2F;&#x2F; TODO_05：使用 req.user 获取用户信息，并使用 data 属性将用户信息发送给客户端 console.log(&#39;admin&#39;) const user &#x3D; req.user console.log(&#39;username: &#39;, user); res.send(&#123; status: 200, message: &#39;获取用户信息成功！&#39;, data: req.user &#x2F;&#x2F; 要发送给客户端的用户信息 &#125;) &#125;) &#x2F;&#x2F; TODO_06：使用全局错误处理中间件，捕获解析 JWT 失败后产生的错误 app.use((err, req, res, next) &#x3D;&gt; &#123; &#x2F;&#x2F; 这次错误是由token解析失败导致的 if (err.name &#x3D;&#x3D;&#x3D; &#39;UnauthorizedError&#39;) &#123; return res.send(&#123; status: 401, message: &#39;无效的token&#39;, &#125;) &#125; else &#123; res.send(&#123; status: 500, message: &#39;未知的错误&#39;, &#125;) &#125; &#125;) &#x2F;&#x2F; 调用 app.listen 方法，指定端口号并启动web服务器 app.listen(8081, function () &#123; console.log(&#39;Express server running at http:&#x2F;&#x2F;127.0.0.1:8081&#39;) &#125;)","categories":[{"name":"node","slug":"node","permalink":"https://2763899039zpp.github.io/categories/node/"}],"tags":[{"name":"js","slug":"js","permalink":"https://2763899039zpp.github.io/tags/js/"},{"name":"node","slug":"node","permalink":"https://2763899039zpp.github.io/tags/node/"}]},{"title":"红宝书","slug":"book/javascript高级程序设计","date":"2023-03-09T08:42:21.000Z","updated":"2023-03-22T06:10:15.858Z","comments":true,"path":"2023/03/09/book/javascript高级程序设计/","link":"","permalink":"https://2763899039zpp.github.io/2023/03/09/book/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"3.1 语法javascript 区分大小写 标识符：第一个字符必须是一个字母、下划线或者美元符号，其他字符可以是字母下划线美元符号或数字 注释： // 单行注释 /* * 这是一个多行块注释 * */ 严格模式：”use strict” 语句：语句以一个分号结尾；条件控制语句建议使用代码块让编码意图更清晰 3.2 关键字和保留字略 3.3 变量ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。 var message = \"hi\"; message = 100; // 有效，但不推荐 3.4 数据类型5 种基本的数据类型：Undefined、Null、Boolean、Number、String1 中简单的复杂类型 Object typeof 结果（string） “undefined” 如果这个值未定义 “boolean” 如果这个值是布尔值 “string” 如果这个值是字符串 “number” 如果这个值是数值 “object” 如果这个值是对象或 null “function” 如果这个值是函数 Undefined 类型Undefined 类型只有一个值，即特殊的 undefined声明变量但是未对其初始化时，这个变量的值就是 undefined 注意：对未初始化的变量执行 typeof 操作符会返回 undefined 值，而对未声明的变量执行 typeof 操作符同样也会返回 undefined 值。 但是未初始化的变量执行 typeof 也会返回 undefined 值 var message; // 声明了变量但没有赋值 默认为undefined // 下面这个变量并没有声明 // var age alert(typeof message); // \"undefined\" alert(typeof age); // \"undefined\" Null 类型从逻辑角度来看，null 值表示一个空对象指针实际上，undefined 值是派生自 null 值的 var car = null; alert(typeof car); // \"object\" alert(null == undefined); //true Boolean 类型该类型只有两个字面值：true 和 false。 转型函数 Boolean() 可将值转化为 Boolean 值 数据类型 转换为 true 的值 转换为 false 的值 Boolean true false String 任何非空字符串 “”（空字符串） Number 任何非零数字值（包括无穷大） 0 和 NaN Object 任何对象 null Undefined n&#x2F;a undefined Number 类型不同的数值字面量格式 ；八进制字面值的第一位必须是零（0）；十六进制前两位必须是 0x var intNum = 55; // 整数 十进制 var octalNum1 = 070; // 八进制的 56 var hexNum1 = 0xa; // 十六进制的 10 浮点数值如果浮点数值本身表示的就是一个整数（如 1.0），那么该值会被转换为整数，节省内存空间 var floatNum1 = 1.1; var floatNum2 = 10.0; // 整数——解析为 10 对于那些极大或极小的数值，可以用 e 表示法（即科学计数法）表示的浮点数值表示 ECMASctipt 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示法表示的数值 var floatNum = 3.125e7; // 等于 31250000 var a = 0.0000003; // 会被转换成 3e-7 数值范围Number.MIN_VALUE 5e-324 Number.MAX_VALUE 1.7976931348623157e+308 超出最大的值会自动转化成 Infinity 负数转化为-Infinity isFinite()函数，想确定一个数值是不是位于最小和最大的数值之间 NaNNaN，即非数值（Not a Number）是一个特殊的数值 NaN 与任何值都不相等，包括 NaN 本身 isNaN()函数：确定这个参数是否“不是数值” 任何不能被转换为数值的值都会导致这个函数返回 true。 alert(isNaN(NaN)); //true alert(isNaN(10)); //false（10 是一个数值） alert(isNaN(\"10\")); //false（可以被转换成数值 10） alert(isNaN(\"blue\")); //true（不能转换成数值） alert(isNaN(true)); //false（可以被转换成数值 1） 字符串&quot;blue&quot;不能被转换成数值，因此函数返回了 true。由于 Boolean 值 true 可以转换成数值 1，因此函数返回 false。 数值转换Number() 如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。 如果是数字值，只是简单的传入和返回。 如果是 null 值，返回 0。 如果是 undefined，返回 NaN。 如果是字符串，遵循下列规则 是数字就转化成 Number 类型的数字， 如果是 16 进制的字符串转化为相同大小的十进制整 如果字符串是空的（不包含任何字符），则将其转换为 0 其他转化为 NaN 数值； var num1 = Number(\"Hello world!\"); //NaN var num2 = Number(\"\"); //0 var num3 = Number(\"000011\"); //11 var num4 = Number(true); //1 parseInt() 它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回 NaN； parseInt()转换空字符串会返回 NaN var num1 = parseInt(\"1234blue\"); // 1234 var num2 = parseInt(\"\"); // NaN var num3 = parseInt(\"0xA\"); // 10（十六进制数） var num4 = parseInt(22.5); // 22 var num5 = parseInt(\"070\"); // 56（八进制数） var num6 = parseInt(\"70\"); // 70（十进制数） var num7 = parseInt(\"0xf\"); // 15（十六进制数） parseInt() 的第二个参数指定转化的基数 即按照某一基数转化 var num1 = parseInt(\"10\", 2); //2 （按二进制解析） var num2 = parseInt(\"10\", 8); //8 （按八进制解析） var num3 = parseInt(\"10\", 10); //10 （按十进制解析） var num4 = parseInt(\"10\", 16); //16 （按十六进制解析） parseFloat() parseFloat()也是从第一个字符（位置 0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。 parseFloat()只解析十进制值 var num1 = parseFloat(\"1234blue\"); //1234 （整数） var num2 = parseFloat(\"0xA\"); //0 var num3 = parseFloat(\"22.5\"); //22.5 var num4 = parseFloat(\"22.34.5\"); //22.34 var num5 = parseFloat(\"0908.5\"); //908.5 var num6 = parseFloat(\"3.125e7\"); //31250000 String 类型1.字符字面量String 数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符 2.字符串的特点ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串 3.转换为字符串toString()方法 null 和 undefined 值没有这个方法。 toString()可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。 var num = 10; alert(num.toString()); // \"10\" alert(num.toString(2)); // \"1010\" alert(num.toString(8)); // \"12\" alert(num.toString(10)); // \"10\" alert(num.toString(16)); // \"a\" String() 方法 如果值有 toString()方法，则调用该方法（没有参数）并返回相应的结果； 如果值是 null，则返回”null”； 如果值是 undefined，则返回”undefined”。 Object 类型Object 的每个实例都具有下列属性和方法 constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是 Object()。 hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty(“name”)）。 isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型（第 5 章将讨论原型）。 propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用 for-in 语句（本章后面将会讨论）来枚举。与 hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。 toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。 toString()：返回对象的字符串表示。 valueOf()：返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值相同。","categories":[{"name":"book","slug":"book","permalink":"https://2763899039zpp.github.io/categories/book/"}],"tags":[{"name":"js","slug":"js","permalink":"https://2763899039zpp.github.io/tags/js/"},{"name":"book","slug":"book","permalink":"https://2763899039zpp.github.io/tags/book/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-03-09T08:25:32.042Z","updated":"2023-03-09T08:25:32.042Z","comments":true,"path":"2023/03/09/hello-world/","link":"","permalink":"https://2763899039zpp.github.io/2023/03/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"book","slug":"book","permalink":"https://2763899039zpp.github.io/categories/book/"},{"name":"node","slug":"node","permalink":"https://2763899039zpp.github.io/categories/node/"}],"tags":[{"name":"js","slug":"js","permalink":"https://2763899039zpp.github.io/tags/js/"},{"name":"book","slug":"book","permalink":"https://2763899039zpp.github.io/tags/book/"},{"name":"node","slug":"node","permalink":"https://2763899039zpp.github.io/tags/node/"}]}